1) Почему использование тестовых заглушек может быть полезным при написании модульных тестов?

    Использование тестовых заглушек может быть полезным при написании модульных тестов, потому что они позволяют изолировать тестируемый код от зависимостей или внешних компонентов.
    Заглушка может имитировать поведение этих зависимостей, что позволяет концентрироваться на тестировании самого модуля.

2) Какой тип тестовой заглушки следует использовать, если вам нужно проверить, что метод был вызван с определенными аргументами?

    Для проверки вызова метода с определенными аргументами используются заглушки-шпионы (spy), которые записывают информацию о вызовах и переданных аргументах. Затем мы можем проверить эти данные в тесте.

3) Какой тип тестовой заглушки следует использовать, если вам просто нужно вернуть определенное значение или исключение в ответ на вызов метода?
    
    Для возвращения конкретных значений или исключений в ответ на вызов метода используются заглушки-подмены (stub). Мы предопределяем, какой результат должен быть возвращен или какое исключение должно быть вызвано при определенном вызове метода.

4) Какой тип тестовой заглушки вы бы использовали для имитации взаимодействия с внешним API или базой данных?

     Для имитации взаимодействия с внешним API или базой данных используются заглушки-заместители (mock). Они позволяют нам имитировать поведение этих компонентов, чтобы мы могли проверить, что наш код правильно взаимодействует с внешними ресурсами.

```python
from unittest import TestCase
from unittest.mock import Mock
from book_service import BookService
from book_repository import BookRepository
from book import Book


class BookServiceTest(TestCase):
    def test_get_books(self):
        # Создаем мок-объект BookRepository
        book_repository = Mock(spec=BookRepository)

        # Создаем список книг, которые мы ожидаем получить от репозитория
        expected_books = [
            Book(title="Book 1", author="Author 1"),
            Book(title="Book 2", author="Author 2"),
            Book(title="Book 3", author="Author 3"),
        ]

        # Устанавливаем ожидаемое поведение мок-объекта
        book_repository.get_books.return_value = expected_books

        # Создаем экземпляр BookService и передаем ему мок-объект BookRepository
        book_service = BookService(book_repository)

        # Вызываем метод get_books у экземпляра BookService
        actual_books = book_service.get_books()

        # Проверяем, что полученный результат совпадает с ожидаемым
        self.assertEqual(actual_books, expected_books)


```
Мы создаем мок-объект BookRepository с помощью Mock(spec=BookRepository), указывая, что этот объект должен соответствовать интерфейсу BookRepository. 
Затем мы устанавливаем ожидаемое поведение мок-объекта с помощью book_repository.get_books.return_value = expected_books, где expected_books - это список книг, которые мы ожидаем получить от репозитория.
Мы создаем экземпляр BookService и передаем ему мок-объект BookRepository. Затем вызываем метод get_books у экземпляра BookService и проверяем, что полученный результат совпадает с ожидаемым с помощью self.assertEqual(actual_books, expected_books).
